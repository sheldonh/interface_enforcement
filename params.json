{"body":"*WARNING* This software does not represent an opinion. It is not a call to\r\ndo things a certain way. It is an exploration of the forces and concerns at\r\nplay when doing things a certain way. Think for yourself, and be kind to\r\nthe children.\r\n\r\nIf you're looking for a polished tool to use, consider these fine efforts\r\ninstead:\r\n\r\n* [Aditya Bhargava's contracts.ruby](http://egonschiele.github.com/contracts.ruby/) - A beautiful DSL for specifying contracts.\r\n* [Josh Cheek's surrogate](Framework to aid in handrolling mock/spy objects.) - A comfortable framework for handrolling mocks and spies.\r\n\r\nThese projects' interface enforcement strategies are different from the one\r\nembodied in this one, but they are well worth consideration.  Contracts.ruby\r\nprovides a fantastic DSL for embedding interface declaration in production\r\ncode, and surrogate tackles the much broader scope of mock and spy specification\r\nand use, with weaker interface enforcement than Contracts.ruby or this project.\r\n\r\nAlso note that one of the dependencies of this gem is currently broken on\r\nruby-1.9.3, as per [sender issue #4](https://github.com/Asher-/sender/issues/4).\r\nI'm currently working around this by applying [ruby pull #47](https://github.com/ruby/ruby/pull/47)\r\nto my ruby.\r\n\r\nDefinition\r\n----------\r\n\r\nThis library provides a construct for applying elective test interface\r\nenforcement in isolated Ruby unit tests:\r\n\r\n* _Elective_: The developer chooses which unit interfaces to enforce, and\r\n  must do so with care and effort, in just those cases that seem important to\r\n  her.\r\n* _Test_: The enforcement construct does not participate in the production\r\n  execution path. It is employed as a proxy around units and the test doubles\r\n  that stand in for them, in tests that exercise those units and doubles.\r\n* _Interface_: An interface describes the accessibility, arguments, return\r\n  values and possible exceptions of the methods of a unit and the test doubles\r\n  that stand in for it. The descriptions are arbitrarily expressive, beyond\r\n  classical type safety.\r\n* _Enforcement_: An enforcement construct raises expressive exceptions when\r\n  the unit or test double it is wrapped around behaves in a way that violates\r\n  the interface.\r\n\r\nIsolated unit tests are those in which at least one test double is standing\r\nin for a module (class, object, module or service) used by the unit under\r\ntest (the test subject).\r\n\r\nDemo\r\n----\r\n\r\nThe file [demo/subscriber\\_spec.rb](/sheldonh/interface_enforcement/tree/master/demo/subscriber_spec.rb)\r\ndemonstrates the risk present in isolated testing in a loosely typed language,\r\nusing a contrived example of an obvious mistake that nobody would make. What is\r\nbeing demonstrated is the mechanism of elective test interface enforcement, not\r\nthe context in which it might be appropriate.\r\n\r\nThe tests for the Subscriber use a test double for the Publisher. However, the\r\ndouble does not behave exactly like the Publisher; its gets method returns a\r\nstring that is not line-terminated. Therefore, the passing test does not test\r\nthe correct use of the Publisher by the Subscriber!\r\n\r\nThe failing test demonstrates the use of an elective interface to detect a test\r\ndouble that does not behave like the object it stands in for.\r\n\r\nThe PublisherInterface would be written by the author of the Publisher, and\r\nwould be used by the authors of both the Publisher and the subscriber. It is\r\ndefined in terms of the InterfaceEnforcement::Enforcer for readability, because the\r\nin situ use of InterfaceEnforcement::Enforcer is more ugly.\r\n\r\nBackground\r\n----------\r\n\r\nThis exploration started when I watched two compelling video presentations:\r\n\r\n* [Fast Rails Tests -- Corey Haines](http://vimeo.com/30893836)\r\n* [Integration Tests Are a Scam -- J.B. Rainsberger](http://www.infoq.com/presentations/integration-tests-scam/)\r\n\r\nJ.B. Rainsberger seemed to be arguing that the only way out of integration test\r\nhell (into which I have descended on more than one occasion) was to test units\r\nin isolation from one another, relying on language-native interface enforcement\r\nto mitigate the risk that test doubles fail to prove correct interation with\r\nthe units they stand in for.\r\n\r\nIn Ruby, as in any loosely-typed (or \"duck-typed\") language, interfaces are\r\nimplicit. An object's interface is the set of methods it will respond to at a\r\ngiven moment, reflecting method definitions applied to it across its life-time\r\nup to that moment.\r\n\r\nAnd so my superficial interpretation of J.B. Rainsberger's hypothesis was that\r\nthe only way out of integration test hell was to\r\n\r\n* accept the risk that changes to a dependency could break its dependents\r\n  without producing failures in the tests of its dependents, or\r\n* use a strictly typed language with explicit interface support!\r\n\r\nI can imagine situations in which one or the other of these responses would be\r\nentirely appropriate. However, the team composition and software rigidity of\r\nmy current situation demand further exploration at the very least.\r\n\r\nThis is why my colleague Ernst van Graan and I began to explore the notion of\r\nelective test interface enforcement in isolated Ruby unit tests.\r\n\r\nWe are not condemning the practice of integration testing. As an aside, neither\r\nwas J.B. Rainsberger; not exactly. We are not promoting any particular style of\r\ntesting. We are simply exploring a mechanism for dealing with the fear inherent\r\na particular style of testing, when the language in play is Ruby.\r\n\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","google":"","name":"Interface enforcement","tagline":"Elective test interface enforcement for Ruby"}